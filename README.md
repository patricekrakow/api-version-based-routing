# API Version-Based Routing

Within an API-Centric Service Mesh, API endpoint requests MUST be routed to service instances implementing a compatible version of the API.

## Abstract

As a _producer_ (or a _provider_), everything starts with designing a beautiful _API_, a beautiful interface that _consumers_ will love to use, expressed in a _OpenAPI document_ that conforms to the [_OpenAPI Specification (OAS)_](https://github.com/OAI/OpenAPI-Specification/tree/main/versions). After (and only after) this (API-)first step, the producer/provider can start coding the implementation of the different _API endpoints_ - uniquely identified by the triplet (HTTP method, host, URL path template) - that make the API.

When these API endpoints are exposed to the outside world, usually via an _API Gateway_, there is a clear distinction between the API, being solely an interface, and its _implementation_. When you call an API endpoint to get a response to your request, you have absolutely no clue about the way the underlying _service_ is implemented. That clear distinction tends to disappear when the API endpoint is exposed within the internal network of the company. Usually, the consumers is calling directly the service as she/he has direct access to the internal address of the service. The fact that the network connectivity is direct, without the additional network hop because of the API Gateway, is the good part. The fact that the producer/provider loses the control she/he can have on the routing of the API endpoint requests, in order to perform, for instance, canary release, is the bad part.

An **_API-Centric Service_** Mesh, based on layer 7 traffic routing capabilities of modern [service meshes](https://servicemesh.es/), aims to unify the Developer eXperience (from both producer and consumer point of views) of API Management whenever the APIs are used externally, internally, or both.

[To be continued...]

## What is (not) a API?

Let's start by defining what we mean when we talk about APIs. The acronym API stands for _**A**pplication_ _**P**rogramming_ _**I**nterface_. It means that an API is, and solely is, an **interface**. We use _interfaces_ to gain access to something running "behind" the API, the _implementation_. Unfortunately, when people use the term "API" they often are talking about not only the interface, but also its implementation. In this paper, we would like to make a radical distinction between the **_API_** being solely an interface and its implementation, which we will call a **_service_**.

This clarification is very important, especially when we will introduce the slippery notion of "version". Indeed, the API, being solely an interface, and its implementation may change separately, and therefore convey each their own version! This confusion between the API, being solely an interface, and its implementation might come from the word "Application". Maybe, if we would have simply created the acronym "PI" for "Programming Interface", or "Program Interface", in a very similar way that we have defined "UI" for "User Interface", things would have been less confusing. A "Program(ing) Interface" would have been the interface to be used by a program - defined as _a series of coded software instructions to control the operation of a computer or other machine_ -, while a "User Interface" would have been the interface to be used by a user. Regrettably, we cannot rewrite history and we have to use the term API. However, we can precise how to understand the word "application" within the acronym API. Let's first defined an application as _a program or piece of software designed to fulfill a particular purpose_. Now, the source of confusion comes from the fact that, in a typical scenario including an API, you usually have **two** programs: the one calling the API and the one implementing the API. If you remember that we defined the API as being solely an interface radically distinct from its implementation, you would agree that the word "application" within the acronym API refers to the software programmatically calling the API! If you are not yet convinced, let me take a rather less typical scenario where the logic of the implementation of an API is not implemented with a series of coded software instructions.

Amazon Web Services (AWS) is well known for its numerous APIs, but have you heard about the [Amazon Mechanical Turk](https://www.mturk.com/) one? It's an API, you can access it from your application, your software, by programmatically calling it. And, what is the capability it does offer? Human Intelligence! Yes, Human Intelligence. Nowadays, you are probably bombarded by offers to access Artificial Intelligence, but little knows that Amazon offers, for years, programmatic access to Human Intelligence. Sarcastically, Amazon even coined the term _artificial artificial intelligence_ to describe this outsourcing of some parts of a computer program to humans, for those tasks carried out much faster by humans than computers. So, an API is always called by an application, but its implementation is not always an application! Closer to you day-to-day experience, you might use a navigation application with a mental model in which your application is using an API to call a software that calculates the best route for you. But, maybe, when you turn right and not left, it is not because its the shorter path for you, but because the software at the other side of the communication channel wants you to update its traffic information about the street on the right, while there are already users, sorry implementers, driving on the street that was at your left...

So, one last time, an **_API_** is solely an interface, distinct from its implementation that we will call a **_service_**.